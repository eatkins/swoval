// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.logging.Logger
import com.swoval.logging.Loggers
import java.io.IOException

object FileTreeRepositories {

  /**
   * Create a file tree repository.
   *
   * @param converter converts a path to the cached value type T
   * @param followLinks toggles whether or not to follow symbolic links. When true, any symbolic
   *     links that point to a regular file will trigger an event when the target file is modified.
   *     For any symbolic links that point to a directory, the children of the target directory will
   *     be included (up to the max depth parameter specified by [[    FileTreeRepository.register]]) and will trigger an event when any of the included children
   *     are modified. When false, symbolic links are not followed and only events for the symbolic
   *     link itself are reported.
   * @tparam T the value type of the cache entries
   * @return a file tree repository.
   */
  def get[T <: AnyRef](converter: Converter[T], followLinks: Boolean): FileTreeRepository[T] =
    get(converter, followLinks, false, Loggers.getLogger)

  /**
   * Create a file tree repository.
   *
   * @param converter converts a path to the cached value type T
   * @param followLinks toggles whether or not to follow symbolic links. When true, any symbolic
   *     links that point to a regular file will trigger an event when the target file is modified.
   *     For any symbolic links that point to a directory, the children of the target directory will
   *     be included (up to the max depth parameter specified by [[    FileTreeRepository.register]]) and will trigger an event when any of the included children
   *     are modified. When false, symbolic links are not followed and only events for the symbolic
   *     link itself are reported.
   * @param rescanOnDirectoryUpdates toggles whether or not we rescan a directory's subtree when an
   *     update is detected for that directory. This can be very expensive since it will perform
   *     iops proportional to the number of files in the subtree. It generally should not be
   *     necessary since we are also watching the subtree for events.
   * @param logger
   * @tparam T the value type of the cache entries
   * @return a file tree repository.
   */
  def get[T <: AnyRef](
      converter: Converter[T],
      followLinks: Boolean,
      rescanOnDirectoryUpdates: Boolean,
      logger: Logger
  ): FileTreeRepository[T] = {
    val symlinkWatcher: SymlinkWatcher =
      if (followLinks)
        new SymlinkWatcher(PathWatchers.get(false, new DirectoryRegistryImpl(), logger), logger)
      else null
    val callbackExecutor: Executor =
      Executor.make("FileTreeRepository-callback-executor")
    val tree: FileCacheDirectoryTree[T] = new FileCacheDirectoryTree[T](
      converter,
      callbackExecutor,
      symlinkWatcher,
      rescanOnDirectoryUpdates,
      logger
    )
    val pathWatcher: PathWatcher[PathWatchers.Event] =
      PathWatchers.get(false, tree.readOnlyDirectoryRegistry(), logger)
    pathWatcher.addObserver(new Observer[Event]() {
      override def onError(t: Throwable): Unit = {}

      override def onNext(event: Event): Unit = {
        tree.handleEvent(event)
      }
    })
    val watcher: FileCachePathWatcher[T] =
      new FileCachePathWatcher[T](tree, pathWatcher)
    new FileTreeRepositoryImpl(tree, watcher)
  }

}
