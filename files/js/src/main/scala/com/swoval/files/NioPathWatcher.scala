// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.PathWatchers.Event.Kind.Create
import com.swoval.files.PathWatchers.Event.Kind.Delete
import com.swoval.files.PathWatchers.Event.Kind.Overflow
import java.util.Map.Entry
import com.swoval.files.FileTreeDataViews.CacheObserver
import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.functional.Consumer
import com.swoval.functional.Either
import com.swoval.functional.Filter
import com.swoval.logging.Logger
import com.swoval.logging.Loggers
import com.swoval.logging.Loggers.Level
import java.io.IOException
import java.nio.file.Path
import java.util.ArrayList
import java.util.HashSet
import java.util.Iterator
import java.util.List
import java.util.Set
import java.util.concurrent.atomic.AtomicBoolean

class RootDirectories extends LockableMap[Path, CachedDirectory[WatchedDirectory]]

/**
 Provides a PathWatcher that is backed by a [[java.nio.file.WatchService]].
 */
class NioPathWatcher(private val directoryRegistry: DirectoryRegistry,
                     watchService: RegisterableWatchService,
                     private val logger: Logger)
    extends PathWatcher[PathWatchers.Event]
    with AutoCloseable {

  private val closed: AtomicBoolean = new AtomicBoolean(false)

  private val observers: Observers[PathWatchers.Event] = new Observers(logger)

  private val rootDirectories: RootDirectories = new RootDirectories()

  private val converter: Converter[WatchedDirectory] =
    new Converter[WatchedDirectory]() {
      override def apply(typedPath: TypedPath): WatchedDirectory =
        if (typedPath.isDirectory && !typedPath.isSymbolicLink)
          Either.getOrElse(service.register(typedPath.getPath), WatchedDirectories.INVALID)
        else WatchedDirectories.INVALID
    }

  private def updateCacheObserver(events: List[Event]): CacheObserver[WatchedDirectory] =
    new CacheObserver[WatchedDirectory]() {
      override def onCreate(newEntry: FileTreeDataViews.Entry[WatchedDirectory]): Unit = {
        events.add(new Event(newEntry.getTypedPath, Create))
        try {
          val it: Iterator[TypedPath] = FileTreeViews
            .list(newEntry.getTypedPath.getPath, 0, new Filter[TypedPath]() {
              override def accept(typedPath: TypedPath): Boolean =
                directoryRegistry.accept(typedPath.getPath)
            })
            .iterator()
          while (it.hasNext) {
            val tp: TypedPath = it.next()
            events.add(new Event(tp, Create))
          }
        } catch {
          case e: IOException => {}

        }
      }

      override def onDelete(oldEntry: FileTreeDataViews.Entry[WatchedDirectory]): Unit = {
        if (oldEntry.getValue.isRight) {
          if (Loggers.shouldLog(logger, Level.DEBUG))
            logger.debug(this + " closing key for " + oldEntry.getTypedPath.getPath)
          oldEntry.getValue.get.close()
        }
        events.add(new Event(oldEntry.getTypedPath, Delete))
      }

      override def onUpdate(oldEntry: FileTreeDataViews.Entry[WatchedDirectory],
                            newEntry: FileTreeDataViews.Entry[WatchedDirectory]): Unit = {}

      override def onError(exception: IOException): Unit = {}
    }

  private val service: NioPathWatcherService = new NioPathWatcherService(
    new Consumer[Event]() {
      override def accept(event: Event): Unit = {
        if (!closed.get) {
          if (event.getKind != Overflow) {
            handleEvent(event)
          } else {
            handleOverflow(event)
          }
        }
      }
    },
    watchService,
    logger
  )

  /**
   * Similar to register, but tracks all of the new files found in the directory. It polls the
   * directory until the contents stop changing to ensure that a callback is fired for each path in
   * the newly created directory (up to the maxDepth). The assumption is that once the callback is
   * fired for the path, it is safe to assume that no event for a new file in the directory is
   * missed. Without the polling, it would be possible that a new file was created in the directory
   * before we registered it with the watch service. If this happened, then no callback would be
   * invoked for that file.
   *
   * @param typedPath The newly created directory to add
   */
  private def add(typedPath: TypedPath, events: List[Event]): Unit = {
    if (directoryRegistry.acceptPrefix(typedPath.getPath)) {
      val dir: CachedDirectory[WatchedDirectory] = getOrAdd(typedPath.getPath)
      if (dir != null) {
        dir.update(typedPath, true).observe(updateCacheObserver(events))
      }
    }
  }

  private def remove(path: Path, events: List[Event]): Unit = {
    val root: CachedDirectory[WatchedDirectory] = rootDirectories.remove(path)
    val dir: CachedDirectory[WatchedDirectory] =
      if (root != null) root else find(path)
    if (dir != null) remove(dir, path, events)
  }

  private def remove(cachedDirectory: CachedDirectory[WatchedDirectory],
                     path: Path,
                     events: List[Event]): Unit = {
    val toCancel: List[FileTreeDataViews.Entry[WatchedDirectory]] =
      cachedDirectory.remove(path)
    if (path == null || path == cachedDirectory.getPath)
      toCancel.add(cachedDirectory.getEntry)
    val it: Iterator[FileTreeDataViews.Entry[WatchedDirectory]] =
      toCancel.iterator()
    while (it.hasNext) {
      val entry: FileTreeDataViews.Entry[WatchedDirectory] = it.next()
      val either: Either[IOException, WatchedDirectory] = entry.getValue
      if (either.isRight) {
        if (events != null) {
          val typedPath: TypedPath = TypedPaths.get(
            entry.getTypedPath.getPath,
            TypedPaths.getKind(entry.getTypedPath) | Entries.NONEXISTENT)
          events.add(new Event(typedPath, Delete))
        }
        either.get.close()
      }
    }
  }

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] = {
    if (Loggers.shouldLog(logger, Level.DEBUG))
      logger.debug(this + " registering " + path + " with max depth " + maxDepth)
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    val existingMaxDepth: Int = directoryRegistry.maxDepthFor(absolutePath)
    val typedPath: TypedPath = TypedPaths.get(absolutePath)
    var realPath: Path = null
    try realPath = absolutePath.toRealPath()
    catch {
      case e: IOException => realPath = absolutePath.toAbsolutePath()

    }
    var result: Either[IOException, Boolean] = Either.right(false)
    if (existingMaxDepth < maxDepth) {
      directoryRegistry.addDirectory(typedPath.getPath, maxDepth)
    }
    val dir: CachedDirectory[WatchedDirectory] = getOrAdd(realPath)
    if (dir != null) {
      result = Either.right(true)
      try dir.update(typedPath, true)
      catch {
        case e: IOException => result = Either.left(e)

      }
    }
    if (Loggers.shouldLog(logger, Level.DEBUG))
      logger.debug(this + " registered " + path + " with max depth " + maxDepth)
    result
  }

  private def find(path: Path): CachedDirectory[WatchedDirectory] = {
    assert((path != null))
    if (rootDirectories.lock()) {
      try {
        val it: Iterator[Entry[Path, CachedDirectory[WatchedDirectory]]] =
          rootDirectories.iterator()
        var result: CachedDirectory[WatchedDirectory] = null
        while (result == null && it.hasNext) {
          val entry: Entry[Path, CachedDirectory[WatchedDirectory]] = it.next()
          val root: Path = entry.getKey
          if (path.startsWith(root)) {
            result = entry.getValue
          }
        }
        result
      } finally rootDirectories.unlock()
    } else {
      null
    }
  }

  private def getOrAdd(path: Path): CachedDirectory[WatchedDirectory] = {
    var result: CachedDirectory[WatchedDirectory] = null
    if (rootDirectories.lock()) {
      try {
        if (!closed.get) {
          result = find(path)
          if (result == null) {
            /*
             * We want to monitor the parent in case the file is deleted.
             */

            var parent: Path = path.getParent
            var init: Boolean = false
            while (!init && parent != null) try {
              result = new CachedDirectoryImpl(
                TypedPaths.get(parent),
                converter,
                java.lang.Integer.MAX_VALUE,
                new Filter[TypedPath]() {
                  override def accept(typedPath: TypedPath): Boolean =
                    typedPath.isDirectory && !typedPath.isSymbolicLink && directoryRegistry
                      .acceptPrefix(typedPath.getPath)
                },
                false
              ).init()
              init = true
              rootDirectories.put(parent, result)
            } catch {
              case e: IOException => parent = parent.getParent

            }
          }
        }
        result
      } finally rootDirectories.unlock()
    } else {
      result
    }
  }

  override def unregister(path: Path): Unit = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    directoryRegistry.removeDirectory(absolutePath)
    if (rootDirectories.lock()) {
      try {
        val dir: CachedDirectory[WatchedDirectory] = find(absolutePath)
        if (dir != null) {
          remove(dir, path, null)
          rootDirectories.remove(dir.getPath)
        }
      } finally rootDirectories.unlock()
    }
    if (Loggers.shouldLog(logger, Level.DEBUG))
      logger.debug(this + " unregistered " + path)
  }

  override def close(): Unit = {
    if (closed.compareAndSet(false, true)) {
      service.close()
      rootDirectories.clear()
    }
  }

  private def handleOverflow(event: Event): Unit = {
    val path: Path = event.getTypedPath.getPath
    if (Loggers.shouldLog(logger, Level.DEBUG))
      logger.debug(this + " received overflow for " + path)
    val events: List[Event] = new ArrayList[Event]()
    if (rootDirectories.lock()) {
      try {
        val root: CachedDirectory[WatchedDirectory] = find(path)
        if (root != null) {
          try {
            val it: Iterator[TypedPath] = FileTreeViews
              .list(
                path,
                0,
                new Filter[TypedPath]() {
                  override def accept(typedPath: TypedPath): Boolean =
                    typedPath.isDirectory && directoryRegistry.acceptPrefix(typedPath.getPath)
                }
              )
              .iterator()
            while (it.hasNext) {
              val file: TypedPath = it.next()
              add(file, events)
            }
          } catch {
            case e: IOException => {
              val removed: List[FileTreeDataViews.Entry[WatchedDirectory]] =
                root.remove(path)
              val removedIt: Iterator[FileTreeDataViews.Entry[WatchedDirectory]] =
                removed.iterator()
              while (removedIt.hasNext) events.add(
                new Event(Entries.setExists(removedIt.next(), false).getTypedPath, Delete))
            }

          }
        }
      } finally rootDirectories.unlock()
    }
    val tp: TypedPath = TypedPaths.get(path)
    events.add(new Event(tp, if (tp.exists()) Overflow else Delete))
    runCallbacks(events)
  }

  private def runCallbacks(events: List[Event]): Unit = {
    val it: Iterator[Event] = events.iterator()
    val handled: Set[Path] = new HashSet[Path]()
    while (it.hasNext) {
      val event: Event = it.next()
      val path: Path = event.getTypedPath.getPath
      if (directoryRegistry.accept(path) && handled.add(path)) {
        observers.onNext(new Event(TypedPaths.get(path), event.getKind))
      }
    }
  }

  private def handleEvent(event: Event): Unit = {
    if (Loggers.shouldLog(logger, Level.DEBUG))
      logger.debug(this + " received event " + event)
    val events: List[Event] = new ArrayList[Event]()
    if (!closed.get && rootDirectories.lock()) {
      try {
        if (directoryRegistry.acceptPrefix(event.getTypedPath.getPath)) {
          val isDelete: Boolean = event.getKind == Delete
          val path: Path = event.getTypedPath.getPath
          val typedPath: TypedPath = TypedPaths.get(path)
          if (isDelete) remove(path, events)
          if (typedPath.exists()) {
            if (typedPath.isDirectory && !typedPath.isSymbolicLink) {
              if (Loggers.shouldLog(logger, Level.DEBUG))
                logger.debug(this + " adding directory for " + typedPath)
              try add(typedPath, events)
              catch {
                case e: IOException => remove(path, events)

              }
            }
          } else if (!isDelete) remove(path, events)
        }
        events.add(event)
      } finally rootDirectories.unlock()
    }
    if (Loggers.shouldLog(logger, Level.DEBUG)) {
      logger.debug(
        this + " generated " + events.toString + " from initial event " +
          event)
    }
    runCallbacks(events)
  }

  override def addObserver(observer: Observer[_ >: Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

}
