// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.files.FileTreeDataViews.CacheObserver
import com.swoval.files.FileTreeDataViews.Entry
import com.swoval.files.FileTreeViews.Observer
import com.swoval.functional.Either
import com.swoval.functional.Filter
import com.swoval.logging.Logger
import com.swoval.logging.Loggers
import com.swoval.logging.Loggers.Level
import com.swoval.runtime.ShutdownHooks
import java.io.IOException
import java.nio.file.Path
import java.util.List
import java.util.concurrent.atomic.AtomicBoolean
import FileTreeRepositoryImpl._

object FileTreeRepositoryImpl {

  abstract class Callback(private val path: Path) extends Runnable with Comparable[Callback] {

    override def compareTo(that: Callback): Int =
      this.path.compareTo(that.path)

  }

}

class FileTreeRepositoryImpl[T <: AnyRef](private val directoryTree: FileCacheDirectoryTree[T],
                                          private val watcher: FileCachePathWatcher[T],
                                          private val logger: Logger)
    extends FileTreeRepository[T] {

  private val closed: AtomicBoolean = new AtomicBoolean(false)

  private val closeRunnable: Runnable = new Runnable() {
    override def run(): Unit = {
      if (closed.compareAndSet(false, true)) {
        ShutdownHooks.removeHook(shutdownHookId)
        watcher.close()
        directoryTree.close()
      }
    }
  }

  private val shutdownHookId: Int = ShutdownHooks.addHook(1, closeRunnable)

  /**
 Cleans up the path watcher and clears the directory cache.
   */
  override def close(): Unit = {
    closeRunnable.run()
  }

  override def addObserver(observer: Observer[_ >: FileTreeDataViews.Entry[T]]): Int =
    addCacheObserver(new CacheObserver[T]() {
      override def onCreate(newEntry: Entry[T]): Unit = {
        observer.onNext(newEntry)
      }

      override def onDelete(oldEntry: Entry[T]): Unit = {
        observer.onNext(oldEntry)
      }

      override def onUpdate(oldEntry: Entry[T], newEntry: Entry[T]): Unit = {
        observer.onNext(newEntry)
      }

      override def onError(exception: IOException): Unit = {
        observer.onError(exception)
      }
    })

  override def removeObserver(handle: Int): Unit = {
    directoryTree.removeObserver(handle)
  }

  override def listEntries(
      path: Path,
      maxDepth: Int,
      filter: Filter[_ >: FileTreeDataViews.Entry[T]]): List[FileTreeDataViews.Entry[T]] =
    directoryTree.listEntries(path, maxDepth, filter)

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] =
    try {
      val absolutePath: Path =
        if (path.isAbsolute) path else path.toAbsolutePath()
      val res: Either[IOException, Boolean] =
        Either.right(watcher.register(absolutePath, maxDepth))
      if (Loggers.shouldLog(logger, Level.DEBUG))
        logger.debug(this + " registered " + path + " with max depth " + maxDepth)
      res
    } catch {
      case e: IOException => Either.left(e)

    }

  override def unregister(path: Path): Unit = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    watcher.unregister(absolutePath)
  }

  override def list(path: Path, maxDepth: Int, filter: Filter[_ >: TypedPath]): List[TypedPath] =
    directoryTree.list(path, maxDepth, filter)

  override def addCacheObserver(observer: CacheObserver[T]): Int =
    directoryTree.addCacheObserver(observer)

}
