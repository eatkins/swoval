// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Filters.AllPass
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind
import com.swoval.files.PathWatchers.FollowSymlinks
import com.swoval.functional.Either
import com.swoval.functional.Filter
import com.swoval.logging.Logger
import java.io.IOException
import java.nio.file.Path
import java.util.Iterator

class SymlinkFollowingPathWatcherImpl(private val pathWatcher: PathWatcher[PathWatchers.Event],
                                      directoryRegistry: DirectoryRegistry,
                                      logger: Logger,
                                      provider: PathWatcherProvider)
    extends FollowSymlinks[Event] {

  private val symlinkWatcher: SymlinkWatcher =
    new SymlinkWatcher(provider.noFollowSymlinks(logger), logger)

  private val observers: Observers[PathWatchers.Event] = new Observers(logger)

  private val pathWatcherDirectoryRegistry: DirectoryRegistry =
    directoryRegistry

  pathWatcher.addObserver(new Observer[Event]() {
    override def onError(t: Throwable): Unit = {
      observers.onError(t)
    }

    override def onNext(event: Event): Unit = {
      val typedPath: TypedPath = event.getTypedPath
      if (typedPath.exists() && typedPath.isSymbolicLink) {
        try {
          val maxDepth: Int = directoryRegistry.maxDepthFor(typedPath.getPath)
          symlinkWatcher.addSymlink(typedPath.getPath, maxDepth)
          if (typedPath.isDirectory) {
            handleNewDirectory(typedPath.getPath, maxDepth, true)
          }
        } catch {
          case e: IOException => observers.onError(e)

        }
      } else if (!typedPath.exists()) {
        symlinkWatcher.remove(typedPath.getPath)
      }
      observers.onNext(event)
    }
  })

  symlinkWatcher.addObserver(observers)

  private def handleNewDirectory(path: Path, maxDepth: Int, trigger: Boolean): Unit = {
    val it: Iterator[TypedPath] =
      FileTreeViews.list(path, maxDepth, AllPass).iterator()
    while (it.hasNext) {
      val tp: TypedPath = it.next()
      if (tp.isSymbolicLink) {
        val p: Path = tp.getPath
        symlinkWatcher.addSymlink(p, pathWatcherDirectoryRegistry.maxDepthFor(p))
      }
      if (trigger) {
        observers.onNext(new Event(tp, Kind.Create))
      }
    }
  }

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    val pathWatcherResult: Either[IOException, Boolean] =
      pathWatcher.register(absolutePath, maxDepth)
    var listResult: Either[IOException, Boolean] = pathWatcherResult
    if (pathWatcherResult.isRight) {
      try {
        handleNewDirectory(absolutePath, maxDepth, false)
        listResult = Either.right(true)
      } catch {
        case e: IOException => listResult = Either.left(e)

      }
    }
    listResult
  }

  override def unregister(path: Path): Unit = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    try {
      val it: Iterator[TypedPath] = FileTreeViews
        .list(
          absolutePath,
          pathWatcherDirectoryRegistry.maxDepthFor(absolutePath),
          new Filter[TypedPath]() {
            override def accept(typedPath: TypedPath): Boolean =
              typedPath.isSymbolicLink
          }
        )
        .iterator()
      while (it.hasNext) symlinkWatcher.remove(it.next().getPath)
    } catch {
      case e: IOException => {}

    }
    pathWatcher.unregister(absolutePath)
  }

  override def close(): Unit = {
    pathWatcher.close()
    symlinkWatcher.close()
  }

  override def addObserver(observer: Observer[_ >: PathWatchers.Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

}
