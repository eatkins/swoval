// Do not edit this file manually. It is autogenerated.

package com.swoval.files

import com.swoval.functional.Filters.AllPass
import com.swoval.files.FileTreeDataViews.CacheObserver
import com.swoval.files.FileTreeDataViews.Converter
import com.swoval.files.FileTreeViews.Observer
import com.swoval.files.PathWatchers.Event
import com.swoval.files.PathWatchers.Event.Kind
import com.swoval.functional.Either
import com.swoval.logging.Logger
import com.swoval.logging.Loggers
import com.swoval.logging.Loggers.Level
import java.io.IOException
import java.nio.file.Files
import java.nio.file.NotDirectoryException
import java.nio.file.Path
import java.util.ArrayList
import java.util.Collections
import java.util.Iterator
import java.util.List
import java.util.Map
import java.util.Map.Entry
import java.util.concurrent.ConcurrentHashMap
import java.util.concurrent.TimeUnit
import java.util.concurrent.atomic.AtomicBoolean

class PollingPathWatcher(private val converter: Converter[java.lang.Long],
                         private val followLinks: Boolean,
                         pollInterval: java.lang.Long,
                         timeUnit: TimeUnit,
                         private val logger: Logger)
    extends PathWatcher[PathWatchers.Event] {

  private val isClosed: AtomicBoolean = new AtomicBoolean(false)

  private val registry: DirectoryRegistry = new DirectoryRegistryImpl()

  private val observers: Observers[PathWatchers.Event] = new Observers(logger)

  private var oldEntries: Map[Path, FileTreeDataViews.Entry[java.lang.Long]] = getEntries

  private val periodicTask: PeriodicTask =
    new PeriodicTask(new PollingRunnable(), timeUnit.toMillis(pollInterval))

  def this(followLinks: Boolean, pollInterval: java.lang.Long, timeUnit: TimeUnit, logger: Logger) =
    this(
      new Converter[java.lang.Long]() {
        override def apply(typedPath: TypedPath): java.lang.Long =
          try Files.getLastModifiedTime(typedPath.getPath).toMillis()
          catch {
            case e: Exception => 0L

          }
      },
      followLinks,
      pollInterval,
      timeUnit,
      logger
    )

  override def register(path: Path, maxDepth: Int): Either[IOException, Boolean] = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    var result: Boolean = false
    val entries: List[FileTreeDataViews.Entry[java.lang.Long]] =
      getEntries(absolutePath, maxDepth)
    this.synchronized {
      addAll(oldEntries, entries)
      result = registry.addDirectory(absolutePath, maxDepth)
    }
    Either.right(result)
  }

  override def unregister(path: Path): Unit = {
    val absolutePath: Path =
      if (path.isAbsolute) path else path.toAbsolutePath()
    registry.removeDirectory(absolutePath)
  }

  override def close(): Unit = {
    if (isClosed.compareAndSet(false, true)) {
      registry.close()
      try periodicTask.close()
      catch {
        case e: InterruptedException =>
          if (Loggers.shouldLog(logger, Level.ERROR)) {
            Loggers.logException(logger, e)
          }

      }
    }
  }

  override def addObserver(observer: Observer[_ >: PathWatchers.Event]): Int =
    observers.addObserver(observer)

  override def removeObserver(handle: Int): Unit = {
    observers.removeObserver(handle)
  }

  private def addAll(map: Map[Path, FileTreeDataViews.Entry[java.lang.Long]],
                     list: List[FileTreeDataViews.Entry[java.lang.Long]]): Unit = {
    val it: Iterator[FileTreeDataViews.Entry[java.lang.Long]] = list.iterator()
    while (it.hasNext) {
      val entry: FileTreeDataViews.Entry[java.lang.Long] = it.next()
      map.put(entry.getTypedPath.getPath, entry)
    }
  }

  private def getEntries(path: Path, maxDepth: Int): List[FileTreeDataViews.Entry[java.lang.Long]] =
    try {
      val view: DirectoryDataView[java.lang.Long] =
        FileTreeDataViews.cached(path, converter, maxDepth, followLinks)
      val newEntries: List[FileTreeDataViews.Entry[java.lang.Long]] =
        view.listEntries(maxDepth, AllPass)
      val pathEntry: List[FileTreeDataViews.Entry[java.lang.Long]] =
        view.listEntries(-1, AllPass)
      if (pathEntry.size == 1) newEntries.add(pathEntry.get(0))
      newEntries
    } catch {
      case e: NotDirectoryException => {
        val result: List[FileTreeDataViews.Entry[java.lang.Long]] =
          new ArrayList[FileTreeDataViews.Entry[java.lang.Long]]()
        val typedPath: TypedPath = TypedPaths.get(path)
        result.add(Entries.get(typedPath, converter, typedPath))
        result
      }

      case e: IOException => Collections.emptyList()

    }

  private def getEntries(): Map[Path, FileTreeDataViews.Entry[java.lang.Long]] = {
// I have to use putAll because scala.js doesn't handle new HashMap(registry.registered()).
    val map: Map[Path, Integer] = new ConcurrentHashMap[Path, Integer]()
    this.synchronized {
      map.putAll(registry.registered())
    }
    val it: Iterator[Entry[Path, Integer]] = map.entrySet().iterator()
    val result: Map[Path, FileTreeDataViews.Entry[java.lang.Long]] =
      new ConcurrentHashMap[Path, FileTreeDataViews.Entry[java.lang.Long]]()
    while (it.hasNext) {
      val entry: Entry[Path, Integer] = it.next()
      val entries: List[FileTreeDataViews.Entry[java.lang.Long]] =
        getEntries(entry.getKey, entry.getValue)
      addAll(result, entries)
    }
    result
  }

  private class PollingRunnable extends Runnable {

    val cacheObserver: CacheObserver[java.lang.Long] = new CacheObserver[java.lang.Long]() {
      override def onCreate(newEntry: FileTreeDataViews.Entry[java.lang.Long]): Unit = {
        observers.onNext(new Event(newEntry.getTypedPath, Kind.Create))
      }

      override def onDelete(oldEntry: FileTreeDataViews.Entry[java.lang.Long]): Unit = {
        observers.onNext(new Event(oldEntry.getTypedPath, Kind.Delete))
      }

      override def onUpdate(oldEntry: FileTreeDataViews.Entry[java.lang.Long],
                            newEntry: FileTreeDataViews.Entry[java.lang.Long]): Unit = {
        if (oldEntry.getValue != newEntry.getValue) {
          observers.onNext(new Event(newEntry.getTypedPath, Kind.Modify))
        }
      }

      override def onError(exception: IOException): Unit = {
        observers.onError(exception)
      }
    }

    override def run(): Unit = {
      val newEntries: Map[Path, FileTreeDataViews.Entry[java.lang.Long]] = getEntries
      MapOps.diffDirectoryEntries(oldEntries, newEntries, cacheObserver)
      this.synchronized {
        oldEntries = newEntries
      }
    }

  }

}
